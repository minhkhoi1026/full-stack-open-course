## Props.children
- The child components are the React elements that we define between the opening and closing tags of a component. `props.children` is automatically added by React and always exists. If a component is defined with an automatically closing `/>` tag, then `props.children` is an *empty array*.

- Where to place state: Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor.

## useRef
- There are a few good use cases for refs:
  - Managing focus, text selection, or media playback.
  - Triggering imperative animations.
  - Integrating with third-party DOM libraries.

- Avoid using refs for anything that can be done declaratively

- In the component that is referenced:
  - The function that creates the component is wrapped inside of a `React.forwardRef` function call. This way the component can access the ref that is assigned to it.
  - The component uses the `useImperativeHandle` hook to make its function available outside of the component.

## Testing in front-end
- Jest is actually configured by default to applications created with `create-react-app`

- Test library for render component is `react-testing-library`
```
npm install --save-dev @testing-library/react @testing-library/jest-dom
```

- `render` returns an object that has several properties. One of the properties is called `container`, and it contains* all of the HTML rendered by the component*

- By default, react testing library runs in watch mode, which means that the `npm test` command will not exit once the tests have finished, and will instead wait for changes to be made to the code. To **avoid this**, use following command:
```
CI=true npm test
```
- There are many way to investigating the content of rendered components
  - `toHaveTextContent` to search for a matching text from the entire HTML code rendered by the component.

  - `getByText` returns the element that contains the given text. An exception occurs if no such element exists.

  -  `querySelector` receives a CSS selector as its parameter then search for a specific element that is rendered by the component.

- Use `component.debug()` to see HTML generated by the component

- Search for a smaller part and print it: `prettyDOM`
```javascript
import { prettyDOM } from '@testing-library/dom

const li = component.container.querySelector('li')
console.log(prettyDOM(li))
```
- `fireEvent` to trigger event

- `jst.fn()` is mock function. Mock function is used for replacing dependencies of the components being tested. Mocks make it possible to return hardcoded responses, and to verify the number of times the mock functions are called and with what parameters.

- Run test with *coverage* option:
```
npm test -- --coverage
```

- Unit tests validate the correct functioning of individual components. Integration testing tests the collaboration of multiple components. E2E tests the system through the same interface as real users use

- Jest offers a completely different alternative to "traditional" testing called snapshot testing. Snapshot tests compare the HTML code defined by the component after it has changed to the HTML code that existed before it was changed. If the snapshot notices some change in the HTML defined by the component, then either it is new functionality or a "bug" caused by accident.

## End to end testing
- We can use Cypress, Selenium, headless browser for end to end testing. Remember avoid flaky test. Here we use cypress.
```
npm install --save-dev cypress
```

- Avoid eslint error:
```
npm install eslint-plugin-cypress --save-dev
```
and in *.eslintrc.js* include this:
```javascript
module.exports = {
    "env": {
        "browser": true,
        "es6": true,
        "jest/globals": true,
        "cypress/globals": true // this
    },
    "plugins": [
        "react", "jest", "cypress" // and this
    ]
}
```

- Graphical test: `cypress open`
- Commandline test: `cypress run`

- Some common method in cypress:
  - `cy.get(selector)`: CSS selector of *the whole page*
  - `cy.contains(text)`: selector by text
  - `cy.request({ url, method, body, headers })`: send a HTML request
  - `cy.visit(url)`: visit page front-end
  - We can chain the selecting process. For example: `cy.contains(text).get(selector)`
  - We can set timeout for command, for example `cy.contains(text, { timeout: 10000 })`, the default timeout is 4s.

- Selected component have some common method for interact with it:
  - `component.type(text)`: type text into component
  - `component.click()`: click the component (trigger `onClick` callback).
  - `component.as(alias)`: save an alias of component for later use. Ex: [link](https://docs.cypress.io/api/commands/as#DOM-element)

- Cypress commands always return `undefined`. They act like promises, so if we want to access their return values, we have to do it using the `then` command.

## Piece information
- Save item for later use: `window.localStorage`. Two common use method: `getItem` and `setItem`.

- React prevent XSS attack by escape every text before render.

- The expected and required props of a component can be defined with the `prop-types` package.
```
npm install prop-types
```